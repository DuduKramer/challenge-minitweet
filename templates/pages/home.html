{% extends 'base.html' %}

{% block head_title %}This is amazing{% endblock head_title %}

{% block content %}
<div class="row text-center">
  <h1>Welcome to Mini-Tweet!</h1>
</div>

<div class="row mb-3">
  <div class="col-md-4 mx-auto col-10">
    <!-- Exibição de erros -->
    <div id="tweet-create-form-error" class="d-none alert alert-danger"></div>
    
    <form class="form" id="tweet-create-form" method="POST" action="/create-tweet">
      {% csrf_token %}
      <input type="hidden" value="/" name="next" />
      <textarea required="required" class="form-control" name="content" placeholder="your tweet..."></textarea>
      <button type="submit" class="btn btn-primary">Tweet</button>
    </form>
  </div>
</div>

<div class="row" id="tweets-container">
  Loading...
</div>

<script>
  function handleTweetError(msg, display) {
      var myErrorDiv = document.getElementById('tweet-create-form-error');
      if(display === true){
        myErrorDiv.setAttribute('class', "d-block alert alert-danger");
        myErrorDiv.innerText = msg;
      }else{
        myErrorDiv.setAttribute('class', "d-none alert alert-danger");
      }
  }
    
  function displayFormErrors(errors) {
      const errorDiv = document.getElementById('tweet-create-form-error');
      errorDiv.classList.remove('d-none');
      errorDiv.innerHTML = '';  // Limpa os erros anteriores
      
      // Exibindo os erros de cada campo
      for (const [field, messages] of Object.entries(errors)) {
          messages.forEach(message => {
              const errorMessage = document.createElement('p');
              errorMessage.textContent = `${message}`;
              errorDiv.appendChild(errorMessage);
          });
      }

      // Remove o erro após 5 segundos
      setTimeout(() => {
          errorDiv.classList.add('d-none');
      }, 5000);  // Tempo em milissegundos (5000ms = 5 segundos)
  }

  async function handleTweetCreateFormDidSubmit(event) {
      event.preventDefault();

      const form = event.target;
      const formData = new FormData(form);
      const url = form.getAttribute('action');
      const method = form.getAttribute('method');

      // Limpa os erros antes de enviar o formulário
      const errorDiv = document.getElementById('tweet-create-form-error');
      errorDiv.classList.add('d-none');  // Esconde o erro antes de tentar enviar novamente

      try {
          const response = await fetch(url, {
              method: method,
              headers: {
                  'X-Requested-With': 'XMLHttpRequest'
              },
              body: formData
          });

          if (!response.ok) {
              const errorData = await response.json();
              console.error('Erro do servidor:', errorData);
              displayFormErrors(errorData);
              return;
          }

          const serverResponse = await response.json();
          console.log('Tweet criado:', serverResponse);
          fetchTweets();
          form.reset();
      } catch (error) {
          console.error('Erro ao enviar o tweet:', error);
      }
  }

  // Evento de escuta para esconder o erro quando o usuário começar a digitar
  const tweetTextArea = document.querySelector('textarea[name="content"]');
  tweetTextArea.addEventListener('input', () => {
      const errorDiv = document.getElementById('tweet-create-form-error');
      errorDiv.classList.add('d-none');  // Esconde o erro assim que o usuário começa a digitar
  });

  const tweetCreateFormEl = document.getElementById('tweet-create-form');
  tweetCreateFormEl.addEventListener('submit', handleTweetCreateFormDidSubmit);

  const tweetsElement = document.getElementById('tweets-container');
  const apiUrl = "/tweets";

  async function fetchTweets() {
    try {
      const response = await fetch(apiUrl);
      if (!response.ok) throw new Error('Network response was not ok');
      const data = await response.json();
      renderTweets(data.response);
    } catch (error) {
      console.error('Fetch error:', error);
      tweetsElement.innerHTML = '<p>Error loading tweets.</p>';
    }
  }

  function handleLike(tweetId, button) {
    let count = parseInt(button.dataset.likes, 10) + 1;
    button.dataset.likes = count;
    button.textContent = `Like (${count})`;
    console.log(`You liked tweet #${tweetId}. Current likes: ${count}`);
  }

  function createLikeButton(tweetId, likes) {
    const button = document.createElement('button');
    button.className = 'btn btn-sm btn-primary ml-2';
    button.textContent = `Like (${likes})`;
    button.dataset.likes = likes;
    button.addEventListener('click', () => handleLike(tweetId, button));
    return button;
  }

  function createTweetElement({ id, content, likes }) {
    const tweetDiv = document.createElement('div');
    tweetDiv.className = 'tweet col-12 border rounded mb-3 p-3 bg-dark text-light';

    const contentP = document.createElement('p');
    contentP.className = 'fs-6 mb-2';
    contentP.textContent = content;

    const likeButton = createLikeButton(id, likes);

    tweetDiv.append(contentP, likeButton);
    return tweetDiv;
  }

  function renderTweets(tweets) {
    tweetsElement.innerHTML = '';

    if (!tweets || tweets.length === 0) {
      tweetsElement.innerHTML = '<p>No tweets available.</p>';
      return;
    }

    tweets.forEach(tweet => {
      const tweetEl = createTweetElement(tweet);
      tweetsElement.appendChild(tweetEl);
    });
  }

  window.addEventListener('DOMContentLoaded', fetchTweets);
</script>

{% endblock content %}
